#!/usr/bin/env python3
"""
Standardized Output Formatter

This module processes the parsed document data and formats it into the
standardized output structure required by the PRD, with top-level keys:
- chunks: List of content elements from the document
- furniture: List of non-content elements
- source_metadata: Metadata about the source document
"""

import json
import logging
import os
from pathlib import Path
from typing import Dict, List, Any, Optional

# Import the logger
from logger_config import logger

def save_standardized_output(document_data: Dict, output_dir: str, pdf_path: Optional[str] = None) -> str:
    """
    Convert the document data to the standardized output format and save it to a file.
    
    Args:
        document_data: The processed document data
        output_dir: Directory to save the output file
        pdf_path: Path to the original PDF file (for metadata)
        
    Returns:
        str: Path to the saved standardized output file
    """
    try:
        logger.info("Formatting document data into standardized output structure")
        
        # Create the standardized output structure
        standardized_output = {
            "chunks": [],
            "furniture": [],
            "source_metadata": {}
        }
        
        # Extract source metadata
        source_metadata = {}
        if pdf_path:
            source_metadata["filename"] = os.path.basename(pdf_path)
            source_metadata["mimetype"] = "application/pdf"
            # Additional metadata could be added here in the future
        
        # If document_data contains metadata, use it
        if "metadata" in document_data:
            for key, value in document_data["metadata"].items():
                source_metadata[key] = value
        
        standardized_output["source_metadata"] = source_metadata
        
        # Process the elements to extract chunks and furniture
        if "elements" in document_data:
            elements = document_data["elements"]
            
            # Create a block counter for assigning block_ids
            block_id_counter = 1
            
            for element in elements:
                # Check if the element is furniture
                if element.get("content_layer") == "furniture":
                    # Extract the text content for furniture
                    if "content" in element:
                        standardized_output["furniture"].append(element["content"])
                else:
                    # Process as a chunk
                    chunk = format_element_as_chunk(element, block_id_counter)
                    if chunk:
                        standardized_output["chunks"].append(chunk)
                        block_id_counter += 1
        
        # Save the standardized output to a file
        output_path = os.path.join(output_dir, "standardized_output.json")
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(standardized_output, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Standardized output saved to {output_path}")
        return output_path
    
    except Exception as e:
        logger.error(f"Error formatting standardized output: {e}", exc_info=True)
        raise

def format_element_as_chunk(element: Dict, block_id: int) -> Optional[Dict]:
    """
    Format an element as a chunk for the standardized output.
    
    Args:
        element: The element to format
        block_id: The block ID to assign to this chunk
        
    Returns:
        Dict: The formatted chunk, or None if the element should be skipped
    """
    try:
        # Skip elements without content
        if "content" not in element and "data" not in element:
            return None
        
        # Determine content type
        content_type = "text"
        if element.get("type") == "table":
            content_type = "table"
        elif element.get("type") == "picture":
            content_type = "image"
        
        # Create the basic chunk structure
        chunk = {
            "_id": None,  # Generated by DB
            "block_id": block_id,
            "doc_id": None,  # External context, set later
            "content_type": content_type,
            "file_type": "application/pdf",
            "master_index": element.get("page_no", 1),
            "master_index2": None,
            "coords_x": None,
            "coords_y": None,
            "coords_cx": None,
            "coords_cy": None,
            "author_or_speaker": None,
            "added_to_collection": None,
            "file_source": element.get("source", ""),
            "table_block": None,
            "modified_date": None,
            "created_date": None,
            "creator_tool": "DoclingToJsonScript_V1.1",
            "external_files": None,
            "text_block": "",
            "header_text": "",
            "text_search": "",
            "user_tags": None,
            "special_field1": None,
            "special_field2": None,
            "special_field3": None,
            "graph_status": None,
            "dialog": None,
            "embedding_flags": None,
            "metadata": {}
        }
        
        # Extract coordinates if available
        if "bbox" in element:
            bbox = element["bbox"]
            if isinstance(bbox, dict):
                chunk["coords_x"] = int(bbox.get("l", 0))
                chunk["coords_y"] = int(bbox.get("t", 0))
                chunk["coords_cx"] = int(bbox.get("r", 0) - bbox.get("l", 0))
                chunk["coords_cy"] = int(bbox.get("b", 0) - bbox.get("t", 0))
        
        # Handle breadcrumb if available
        breadcrumb = element.get("breadcrumb", "")
        chunk["header_text"] = breadcrumb
        chunk["special_field2"] = breadcrumb
        
        # Process content based on type
        if content_type == "text":
            chunk["text_block"] = f"{breadcrumb}\n\n{element.get('content', '')}"
            chunk["text_search"] = element.get("content", "")
        
        elif content_type == "table":
            # Format table as JSON string
            if "data" in element:
                chunk["table_block"] = json.dumps(element["data"])
                # Create a text representation for search
                text_content = []
                for row in element.get("data", []):
                    text_content.append(" | ".join(str(cell) for cell in row))
                chunk["text_search"] = "\n".join(text_content)
                chunk["text_block"] = f"{breadcrumb}\n\n[Table content]"
        
        elif content_type == "image":
            # Handle image content
            chunk["external_files"] = element.get("image_path", "")
            # OCR text if available
            image_text = element.get("ocr_text", "")
            preceding_text = element.get("preceding_text", "")
            succeeding_text = element.get("succeeding_text", "")
            
            # Format image text block as specified in PRD
            chunk["text_block"] = f"{breadcrumb}\n\n{preceding_text}\n\n[Image Text: {image_text}]\n\n{succeeding_text}"
            chunk["text_search"] = image_text
        
        # Build the metadata object
        metadata = {
            "breadcrumb": breadcrumb,
            "page_no": element.get("page_no", 1),
        }
        
        # Add bbox if available
        if "bbox" in element:
            metadata["bbox_raw"] = element["bbox"]
        
        # Add caption if available
        if "caption" in element:
            metadata["caption"] = element["caption"]
        
        # Add context before/after if available
        if "context_before" in element:
            metadata["context_before"] = element["context_before"]
        
        if "context_after" in element:
            metadata["context_after"] = element["context_after"]
        
        # Add docling-specific metadata
        metadata["docling_label"] = element.get("type", "text")
        metadata["docling_ref"] = element.get("self_ref", "")
        
        # Add image-specific metadata
        if content_type == "image":
            metadata["image_mimetype"] = element.get("mimetype", "image/png")
            metadata["image_width"] = element.get("width", 0)
            metadata["image_height"] = element.get("height", 0)
            metadata["image_ocr_text"] = element.get("ocr_text", "")
        
        # Add metadata to chunk
        chunk["metadata"] = metadata
        chunk["special_field1"] = json.dumps(metadata)
        
        return chunk
    
    except Exception as e:
        logger.error(f"Error formatting element as chunk: {e}", exc_info=True)
        return None 