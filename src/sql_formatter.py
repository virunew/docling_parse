"""
SQL Formatter for Docling Parser

This module provides functionality to convert the parsed Docling document data
into a standardized JSON format suitable for SQL database ingestion.
"""
import json
import logging
from typing import Dict, List, Any, Optional, Union

# Import the logger configuration
from logger_config import logger

def process_docling_json_to_sql_format(document_data: Dict[str, Any], 
                                       doc_id: Optional[str] = None) -> Dict[str, Any]:
    """
    Process the Docling document data and convert it to a standardized SQL-compatible format.
    
    Args:
        document_data (Dict[str, Any]): The parsed Docling document data
        doc_id (Optional[str]): Optional document ID to use in the output
        
    Returns:
        Dict[str, Any]: A dictionary with the standardized output format containing
                        chunks, furniture, and source_metadata
    """
    logger.info("Processing document data into SQL-compatible format")
    
    try:
        # Initialize the output structure
        output = {
            "chunks": [],
            "furniture": [],
            "source_metadata": {
                "filename": document_data.get("metadata", {}).get("filename", ""),
                "mimetype": document_data.get("metadata", {}).get("mimetype", "application/pdf"),
                "binary_hash": document_data.get("metadata", {}).get("binary_hash", "")
            }
        }
        
        # Extract furniture elements
        if "furniture" in document_data:
            for furniture_item in document_data.get("furniture", []):
                if furniture_item.get("text"):
                    output["furniture"].append(furniture_item["text"])
        
        # Process content elements into chunks
        block_id = 1
        for element in document_data.get("body", []):
            content_type = _determine_content_type(element)
            
            # Create chunk with all required fields from the fusa_library schema
            chunk = {
                "_id": None,  # Generated by DB
                "block_id": block_id,
                "doc_id": doc_id,
                "content_type": content_type,
                "file_type": output["source_metadata"]["mimetype"],
                "master_index": _extract_page_number(element),
                "master_index2": None,
                "coords_x": _extract_coord(element, "l"),
                "coords_y": _extract_coord(element, "t"),
                "coords_cx": _extract_coord(element, "r") - _extract_coord(element, "l"),
                "coords_cy": _extract_coord(element, "b") - _extract_coord(element, "t"),
                "author_or_speaker": None,
                "added_to_collection": None,
                "file_source": output["source_metadata"]["filename"],
                "table_block": _format_table_content(element) if content_type == "table" else None,
                "modified_date": None,
                "created_date": None,
                "creator_tool": "DoclingToJsonScript_V1.1",
                "external_files": _get_external_file_path(element) if content_type == "image" else None,
                "text_block": _format_text_block(element, _get_breadcrumb(element)),
                "header_text": _get_breadcrumb(element),
                "text_search": _get_searchable_text(element),
                "user_tags": None,
                "special_field1": json.dumps(_build_metadata_object(element)),
                "special_field2": _get_breadcrumb(element),
                "special_field3": None,
                "graph_status": None,
                "dialog": None,
                "embedding_flags": None,
                "metadata": _build_metadata_object(element)
            }
            
            output["chunks"].append(chunk)
            block_id += 1
        
        logger.info(f"Successfully processed document data: {len(output['chunks'])} chunks, {len(output['furniture'])} furniture items")
        return output
    
    except Exception as e:
        logger.error(f"Error processing document data: {e}", exc_info=True)
        raise

def _determine_content_type(element: Dict[str, Any]) -> str:
    """Determine the content type (text, table, or image) of an element."""
    element_type = element.get("type", "")
    
    if element_type == "table":
        return "table"
    elif element_type == "picture":
        return "image"
    else:
        return "text"

def _extract_page_number(element: Dict[str, Any]) -> int:
    """Extract the page number from an element."""
    prov = element.get("prov", {})
    return prov.get("page_no", 1)

def _extract_coord(element: Dict[str, Any], coord_key: str) -> int:
    """Extract coordinate value from an element's bounding box."""
    prov = element.get("prov", {})
    bbox = prov.get("bbox", {})
    coord = bbox.get(coord_key, 0)
    return int(coord)

def _format_table_content(element: Dict[str, Any]) -> Optional[str]:
    """Format table content as a JSON string of the grid."""
    if not element.get("grid"):
        return None
    
    try:
        return json.dumps(element["grid"])
    except Exception as e:
        logger.warning(f"Error formatting table content: {e}")
        return None

def _get_external_file_path(element: Dict[str, Any]) -> Optional[str]:
    """Get the path to an externally stored image file."""
    if "external_path" in element:
        return element["external_path"]
    return None

def _get_breadcrumb(element: Dict[str, Any]) -> str:
    """Get the hierarchical breadcrumb for an element."""
    return element.get("breadcrumb", "")

def _format_text_block(element: Dict[str, Any], breadcrumb: str) -> str:
    """Format the text block with breadcrumb and content."""
    content = ""
    
    if _determine_content_type(element) == "text":
        content = element.get("text", "")
    elif _determine_content_type(element) == "image":
        # Format for images: preceding text, image text (OCR), and succeeding text
        preceding_text = element.get("context_before", "")
        image_ocr_text = element.get("ocr_text", "")
        succeeding_text = element.get("context_after", "")
        
        content = f"{preceding_text}\n\n[Image Text: {image_ocr_text}]\n\n{succeeding_text}"
    elif _determine_content_type(element) == "table":
        content = f"[Table: {element.get('caption', 'Table content')}]"
    
    return f"{breadcrumb}\n\n{content}" if breadcrumb else content

def _get_searchable_text(element: Dict[str, Any]) -> str:
    """Get text for search indexing."""
    if _determine_content_type(element) == "text":
        return element.get("text", "")
    elif _determine_content_type(element) == "image":
        return element.get("caption", "") or element.get("ocr_text", "")
    elif _determine_content_type(element) == "table":
        return element.get("caption", "")
    return ""

def _build_metadata_object(element: Dict[str, Any]) -> Dict[str, Any]:
    """Build a complete metadata object for an element."""
    content_type = _determine_content_type(element)
    prov = element.get("prov", {})
    bbox = prov.get("bbox", {})
    
    metadata = {
        "breadcrumb": _get_breadcrumb(element),
        "page_no": _extract_page_number(element),
        "bbox_raw": {
            "l": bbox.get("l", 0),
            "t": bbox.get("t", 0),
            "r": bbox.get("r", 0),
            "b": bbox.get("b", 0)
        },
        "caption": element.get("caption", ""),
        "context_before": element.get("context_before", ""),
        "context_after": element.get("context_after", ""),
        "docling_label": element.get("type", ""),
        "docling_ref": element.get("self_ref", "")
    }
    
    # Add image-specific metadata
    if content_type == "image":
        metadata.update({
            "image_mimetype": element.get("mimetype", "image/png"),
            "image_width": element.get("width", 0),
            "image_height": element.get("height", 0),
            "image_ocr_text": element.get("ocr_text", "")
        })
    
    return metadata 